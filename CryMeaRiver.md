---
# Cry Me a River

| Chal info | FCSC2023 |
| ------ | ----------- |
| Name | Cry Me a River |
| Category   | Crypto |
| Difficulty | :star: :star: :star: |
| Number of solves | 10 |
| Type | ECDSA key recovery from biased nonce |

In this challenge, Justin provides us with the following code (and a very helpful meme).

``` py
import os
from hashlib import sha512
from fastecdsa.curve import P521

def H(m):
    ctx = sha512()
    ctx.update(m)
    return ctx.digest()

class Random:
    def __init__(self):
        self.state = int.from_bytes(os.urandom(16), "little")
        self.a = 200565257846616591441313188858237974233
        self.c = 1
        self.m = 128

    def randint(self):
        r = self.state
        self.state = (self.a * self.state + self.c) % 2 ** self.m
        return r

    def nonce(self):
        r = 0
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        return r

class ECDSA:
    def __init__(self):
        self.C = P521
        self.rng = Random()
        self.sk = int.from_bytes(os.urandom(48), "little")
        self.Q = self.sk * self.C.G
        assert self.Q.IDENTITY_ELEMENT != self.Q

    def sign(self, msg):
        k = self.rng.nonce()
        h = int.from_bytes(H(msg), "little")
        P = k * self.C.G
        r = P.x % self.C.q
        assert r > 0, "Error: cannot sign this message."

        s = (pow(k, -1, self.C.q) * (h + self.sk * r)) % self.C.q
        assert s > 0, "Error: cannot sign this message."

        return r, s

    def verify(self, msg, sig):
        r, s = sig
        if r < 1 or r >= self.C.q: return False
        if s < 1 or s >= self.C.q: return False
        h = int.from_bytes(H(msg), "little")
        s_inv = pow(s, -1, self.C.q)
        u = h * s_inv % self.C.q
        v = r * s_inv % self.C.q
        P = u * self.C.G + v * self.Q
        return r == P.x

if __name__ == "__main__":

    try:
        S = ECDSA()
        print(f"Public Point Q: ({S.Q.x}, {S.Q.y})")
        print("Here is a valid signature!")
        m = os.urandom(24)
        r, s = S.sign(m)
        print(f"m = 0x{m.hex()}")
        print(f"sig = ({r}, {s})")
        assert S.verify(m, (r, s))

        print("You turn! Give me another one!")
        r = int(input("r = "))
        s = int(input("s = "))
        sig = (r, s)
        if S.verify(b"All right, everybody be cool, this is a robbery! Give me the flag!", sig):
            flag = open("flag.txt").read()
            print(flag)
        else:
            print("Nope!")
    except:
        print("Please check your inputs.")

```

This implements the famous [ECDSA signature algorithm](https://fr.wikipedia.org/wiki/Elliptic_curve_digital_signature_algorithm), on NIST curve [P521](https://neuromancer.sk/std/nist/P-521). Notice that we know a canonical generator $G$ for the points on the curve, and its order $q$.

The challenge provides us with the public point $Q$, a message $m$ and its signature $(r,s)$. It then prompts the user to give another valid signature. Here I first fell into the trap of thinking that this new signature had to be a signature of $m$, but if we read the code carefully, we need a valid signature of a given message: `"All right, everybody be cool, this is a robbery! Give me the flag!"`. In both cases, this means that we are going to need to recover the secret key $sk$.

We now look through the code again to find potential vulnerabilities:
- The secret key is generated by `os.urandom(48)`, making it $8\cdot48=384$ bits. A small detail maybe, but this is strange! $q$ has $521$ bits, which leaves a big gap. Maybe Justin wanted a very short secret key. We will come back to this later on.
- Now for the elephant in the room, the nonce $k$ is being generated by a very intriguing procedure. I thought nonces had to be perfectly pseudorandom ðŸ¤”.

$k$ is in fact generated by the concatenation of four $128$ bit numbers, generated by a [Linear Congruential Generator](https://en.wikipedia.org/wiki/Linear_congruential_generator)(LCG). This LCG uses a prime $a$ and modulus $2^{128}$. This means our nonce $k$ only has $128$ bits of pseudorandomness, less than a quarter of its size!

But how can we exploit this?? most CTF enthusiasts are probably familiar with key recovery lattice attacks on ECDSA with biased nonces (see [this paper](https://www.di.ens.fr/~pnguyen/pub_NgSh02.html)). 

Here is a quick rundown of the technique:

Suppose we have a bunch of ECDSA signatures $(r_i,s_i)_{i\le n}$ of messages $m_i$, all from the same secret key $sk$, and suppose the nonces $k_1,\ldots,k_n$ are somehow biased, for example imagine we know they are all shorter than expected.

A bit of maths (or looking at the code for `verify`) tells us that for all $i$, 
$$k\equiv s_i^{-1}H(m_i)+s_i^{-1}r\cdot sk (\text{mod } q).$$

We can rewrite these equations as "$u_i + t_i\cdot sk -j_iq=k_i$ is short" for some integer $j_i$ and appropriate values of $u_i,t_i$. This is in fact an instance of the Hidden Number Problem, and if the nonces are small enough and the number of signatures is big enough, we can recover the solution $sk$ by LLL-reducing the following lattice:

$$\begin{matrix} q & 0 & \ldots & 0 & 0 & 0\\ 0 & q & \ldots & 0 & 0 & 0 \\ \vdots & 0 & \ddots & 0 & \vdots & \vdots \\ 0 & \ldots & 0 & q & 0 & 0 \\ t_1 & t_2 &\ldots & t_n & 1 & 0 \\ u_1 & u_2 &\ldots & u_n & 0 & q \end{matrix}$$

Why does this lattice work? 

First it is quite clear that $v=(k_1,\ldots,k_n,sk,q)$ is in the lattice, and that it is relatively short (recall that the $k_i$ were somewhat shorter than expected).

If parameters are chosen in a way that $v$ is smaller than the short vectors that we would expect (this depends on the volume of the lattice), the if the dimension is not too big, LLL should return $v$ efficiently. This immediatly recovers $sk$.

Life would be too good if this attack was sufficient here, in fact we can try but we will run into some problems (time to listen to [that song](https://www.youtube.com/watch?v=DksSPZTZES0) again):
- We only get one signature
- Our bias on $k$ is not immediatly linear (if we had $k\equiv\alpha + \beta x$ mod $q$ for some really short $x$ the above approach might work. But the LCG makes things a bit more complicated.


