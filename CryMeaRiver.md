---
# Cry Me a River

| Chal info | FCSC2023 |
| ------ | ----------- |
| Name | Cry Me a River |
| Category   | Crypto |
| Difficulty | :star: :star: :star: |
| Number of solves | 10 |
| Type | ECDSA key recovery from biased nonce |
| Writeup by | htmb |

In this challenge, Justin provides us with the following code (and a very helpful meme).

``` py
import os
from hashlib import sha512
from fastecdsa.curve import P521

def H(m):
    ctx = sha512()
    ctx.update(m)
    return ctx.digest()

class Random:
    def __init__(self):
        self.state = int.from_bytes(os.urandom(16), "little")
        self.a = 200565257846616591441313188858237974233
        self.c = 1
        self.m = 128

    def randint(self):
        r = self.state
        self.state = (self.a * self.state + self.c) % 2 ** self.m
        return r

    def nonce(self):
        r = 0
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        r = (r << self.m) | self.randint()
        return r

class ECDSA:
    def __init__(self):
        self.C = P521
        self.rng = Random()
        self.sk = int.from_bytes(os.urandom(48), "little")
        self.Q = self.sk * self.C.G
        assert self.Q.IDENTITY_ELEMENT != self.Q

    def sign(self, msg):
        k = self.rng.nonce()
        h = int.from_bytes(H(msg), "little")
        P = k * self.C.G
        r = P.x % self.C.q
        assert r > 0, "Error: cannot sign this message."

        s = (pow(k, -1, self.C.q) * (h + self.sk * r)) % self.C.q
        assert s > 0, "Error: cannot sign this message."

        return r, s

    def verify(self, msg, sig):
        r, s = sig
        if r < 1 or r >= self.C.q: return False
        if s < 1 or s >= self.C.q: return False
        h = int.from_bytes(H(msg), "little")
        s_inv = pow(s, -1, self.C.q)
        u = h * s_inv % self.C.q
        v = r * s_inv % self.C.q
        P = u * self.C.G + v * self.Q
        return r == P.x

if __name__ == "__main__":

    try:
        S = ECDSA()
        print(f"Public Point Q: ({S.Q.x}, {S.Q.y})")
        print("Here is a valid signature!")
        m = os.urandom(24)
        r, s = S.sign(m)
        print(f"m = 0x{m.hex()}")
        print(f"sig = ({r}, {s})")
        assert S.verify(m, (r, s))

        print("You turn! Give me another one!")
        r = int(input("r = "))
        s = int(input("s = "))
        sig = (r, s)
        if S.verify(b"All right, everybody be cool, this is a robbery! Give me the flag!", sig):
            flag = open("flag.txt").read()
            print(flag)
        else:
            print("Nope!")
    except:
        print("Please check your inputs.")

```

This implements the famous [ECDSA signature algorithm](https://fr.wikipedia.org/wiki/Elliptic_curve_digital_signature_algorithm), on NIST curve [P521](https://neuromancer.sk/std/nist/P-521). Notice that we know a canonical generator $G$ for the points on the curve, and its order $q$.

The challenge provides us with the public point $Q$, a message $m$ and its signature $(r,s)$. It then prompts the user to give another valid signature. Here I first fell into the trap of thinking that this new signature had to be a signature of $m$, but if we read the code carefully, we need a valid signature of a given message: `"All right, everybody be cool, this is a robbery! Give me the flag!"`. In both cases, this means that we are going to need to recover the secret key $sk$.

We now look through the code again to find potential vulnerabilities:
- The secret key is generated by `os.urandom(48)`, making it $8\cdot48=384$ bits. A small detail maybe, but this is strange! $q$ has $521$ bits, which leaves a big gap. Maybe Justin wanted a very short secret key. We will come back to this later on.
- Now for the elephant in the room, the nonce $k$ is being generated by a very intriguing procedure. I thought nonces had to be perfectly pseudorandom ðŸ¤”.

$k$ is in fact generated by the concatenation of four $128$ bit numbers, generated by a [Linear Congruential Generator](https://en.wikipedia.org/wiki/Linear_congruential_generator)(LCG). This LCG uses a prime $a$ and modulus $2^{128}$. This means our nonce $k$ only has $128$ bits of pseudorandomness, less than a quarter of its size!

But how can we exploit this?? most CTF enthusiasts are probably familiar with key recovery lattice attacks on ECDSA with biased nonces (see [this paper](https://www.di.ens.fr/~pnguyen/pub_NgSh02.html)). 

Here is a quick rundown of the technique:

Suppose we have a bunch of ECDSA signatures $(r_i,s_i)_{i\le n}$ of messages $m_i$, all from the same secret key $sk$, and suppose the nonces $k_1,\ldots,k_n$ are somehow biased, for example imagine we know they are all shorter than expected.

A bit of maths (or looking at the code for `verify`) tells us that for all $i$, 
$$k\equiv s_i^{-1}H(m_i)+s_i^{-1}r\cdot sk (\text{mod } q).$$

We can rewrite these equations as "$u_i + t_i\cdot sk -j_iq=k_i$ is short" for some integer $j_i$ and appropriate values of $u_i,t_i$. This is in fact an instance of the Hidden Number Problem, and if the nonces are small enough and the number of signatures is big enough, we can recover the solution $sk$ by LLL-reducing the lattice generated by the following matrix:

```math
\begin{pmatrix} q & 0 & \ldots & 0 & 0 & 0\\ 0 & q & \ddots & 0 & 0 & 0 \\ \vdots &  &  & \vdots & \vdots & \vdots \\ 0 & 0 & \ldots & q & 0 & 0 \\ t_1 & t_2 &\ldots & t_n & 1 & 0 \\ u_1 & u_2 & \ldots & u_n & 0 & q \end{pmatrix}$$
```

Why does this lattice work? 

First it is quite clear that $v=(k_1,\ldots,k_n,sk,q)$ is in the lattice, and that it is relatively short (recall that the $k_i$ were somewhat shorter than expected).

If parameters are chosen in a way that $v$ is smaller than the short vectors that we would expect (this depends on the volume of the lattice), the if the dimension is not too big, LLL should return $v$ efficiently. This immediatly recovers $sk$.

Life would be too good if this attack was sufficient here, in fact we can try but we will run into some problems (time to listen to [that song](https://www.youtube.com/watch?v=DksSPZTZES0) again):
- We only get one signature
- Our bias on $k$ is not immediatly linear (if we had $k\equiv\alpha + \beta x$ mod $q$ for some really short $x$ the above approach might work. But the LCG makes things a bit more complicated.

After a bit of research, we find the answer in [this paper](https://cseweb.ucsd.edu/~mihir/papers/dss-lcg.pdf). We are exactly in the situation described by section 5.2, but for ECDSA instead of DSA. We can now start solving.

The nonce can be rewritten as $k = 2^{384}k_1+2^{256}k_2+2^{128}k_3+k_4$, where $1\le k_i\le2^{128}-1$. 

This means that for given values of $m$ and $(r,s)$, we have the following system has to be satisfied:

```math
\begin{cases}
&2^{384}k_1+&2^{256}k_2+&2^{128}k_3+&k_4 -s^{-1}r\cdot sk &\equiv& s^{-1}H(m) &(\text{mod }q)\\
&-ak_1+&k_2&&&\equiv&0&(\text{mod }2^{128})\\
&&-ak_2+&k_3&&\equiv&0&(\text{mod }2^{128})\\
&&&-ak_3+&k_4&\equiv&0&(\text{mod }2^{128})
\end{cases}
```

We now recall that $sk\le 2^{384}-1$, making our unknowns all relatively small. Lattice reduction can help solve this system of modular equations. Note that the constant terms on the right are not all $0$, meaning that we will need to solve a Closest Vector Problem (CVP) instead of just outputing a short vector.

CVP is in general a very hard problem, however if we know a reduced basis of the lattice, it can be solved efficiently with an approximation factor not too large in small dimensions. The usual procedures for this are Babai Round-Off and Babai Nearest-Plane. Babai Nearest-Plane usually gives better results for a very small extra computational cost, especially for lattices that aren't naturally orthogonal. Here is some sagemath code that does just that.

```py
def dot(A,B):
    return(sum([A[i]*B[i] for i in range(len(A))]))    

def Babai_NP(M, G, target):
    '''Computes a vector of the lattice M that is close to target, using the gram_schmidt matrix G'''
    small = target
    for i in reversed(range(M.nrows())):
        c = (dot(small,G[i]) / dot(G[i],G[i])).round()
        #print(target)
        small -=  c * M[i]
    return target - small
```

Let's build the lattice from the modular system: it has the following basis ($s^{-1}$ denotes inversion mod $q$):

```math
\begin{pmatrix} (-s^{-1}r \% q) & 2^{384} & 2^{256} & 2^{128} & 1 & q & 0 & 0 & 0\\
0 & -a & 1 & 0 & 0 & 0 & 2^{128} & 0 & 0\\
0 & 0 & -a & 1 & 0 & 0 & 0 & 2^{128} & 0\\
0 & 0 & 0 & -a & 1 & 0 & 0 & 0 & 2^{128}\\
2/2^{384} & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 2/2^{128} & 0 & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 2/2^{128} & 0 & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 2/2^{128} & 0 & 0 & 0 & 0 & 0\\
0 & 0 & 0 & 0 & 2/2^{128} & 0 & 0 & 0 & 0
\end{pmatrix}$$
```

Here is the intuition behind this construction (column notation):
- The top left $5\times5$ block corresponds to our system of equations.
- The rightmost $4$ columns corresponds to the moduli used in our equation, they can be freely added or subtracted to the other columns.
- The lower left $5\times5$ block is a control block, that serves two purposes: it controls the size of the unknowns that are allowed in our equation (for example, if a $k_i$ was too large, its control row would explode and make the output vector large); and it gives us an easy way to recover the values of said unknowns.

The target vector is $(s^{-1},0,0,0,0,0,0,0,0)^t$. The paper mentions the need to test multiple target vectors for a provable result but we won't need this here as the organisers have chosen nice parameters.

We can now implement a solution in sage:

First define the hash function and the parameters:

```py
import os
from hashlib import sha512

def H(m): #copied from challenge code
    ctx = sha512()
    ctx.update(m)
    return ctx.digest()

a = 200565257846616591441313188858237974233 #LCG parameter

p = 2^521 - 1
F = GF(p)
A = p - 3
B = 1093849038073734274511112390766805569936207598951683748994586394495953116150735016013708737573759623248592132296706313309438452531591012912142327488478985984
q = 6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449
E = EllipticCurve([F(A), F(B)]) #P521
Gx = 0xc6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66
Gen = E.lift_x(Gx) #point G

#Toy values for the challenge
m = "9809e1263f3cc8af8c60145a27716c5fbb6c0b700ae77d8f"
h = int.from_bytes(H(bytes.fromhex(m)),"little")
Q = E(1792314938292812613330865975005804991527437672131928733340881444121809578897115157505967506967432437378645724348556619547497204468649955581436436559018190735, 2141713752008192915375941884855134148785970302053848726749106432718389564414400415169079340151078086108803964201574534654534835548341685770010022783046966686)
r,s =  (897632435062803360671859808910188036781946987858348348959236332082197828387874347727946495912674480879378524696182083016375150628565926615028141767926087571, 1982759473752910615830058585737816740161213400486833132267919239818510833617099175081600705142460969889303710833868646376997884619581479596331861767785224859)
```

Now define the lattice and CVP target. Sage uses row notation so we transpose.

```py
B = Matrix([
    [ (-inverse_mod(s,q)*r) % q, 2**384, 2**256, 2**128, 1, q, 0, 0, 0 ], # sk
    [ 0, -a, 1, 0, 0, 0, 2**128, 0, 0 ], 
    [ 0, 0, -a, 1, 0, 0, 0, 2**128, 0 ], 
    [ 0, 0, 0, -a, 1, 0, 0, 0, 2**128 ],
    [ 2/2**384, 0, 0, 0, 0, 0, 0, 0, 0,],
    [ 0, 2/2**128, 0, 0, 0, 0, 0, 0, 0,],
    [ 0, 0, 2/2**128, 0, 0, 0, 0, 0, 0,],
    [ 0, 0, 0, 2/2**128, 0, 0, 0, 0, 0,],
    [ 0, 0, 0, 0, 2/2**128, 0, 0, 0, 0,]
]).transpose()
Y = vector([ (inverse_mod(s,q)*h) % q, 1, 1, 1, 1, 1, 1, 1, 1 ])
```
Sage has a built-in LLL implementation, which enables us to get an adequate close vector $V$. If its first four coordinates are equal to those of the target, we are very happy as this means the system is satisfied (otherwise we would have to randomise the last coordinates of the target and the associated control values). We then recover the secret key by dividing out by the appropriate control value.

```py
M = B.LLL() #reduce
G_M = M.gram_schmidt()[0] #preparing the CVP
V = Babai_NP(M, G_M, Y) #CVP

assert (V[0] == Y[0] and V[1] == Y[1] and V[2] == Y[2] and V[3] == Y[3]) #just in case

sk = V[4]/B[0,4] #key recovery!
```

Time to forge the signature ðŸ˜ˆ, for example using nonce equal to $1$, but any value works.

```py
msg = b"All right, everybody be cool, this is a robbery! Give me the flag!"
h_f = int.from_bytes(H(msg), "little")
P = Gen
r_f = P[0]
s_f = (h_f + Integer(sk) * Integer(r)) % q
assert s > 0, "Error: cannot sign this message."
print((r_f,s_f))
```
This gives us 
`r_f = 2661740802050217063228768716723360960729859168756973147706671368418802944996427808491545080627771902352094241225065558662157113545570916814161637315895999846`
`s_f = 6226585010542561397945940684568663168625172022419364133354436272263050888170496659941205691896364739692692807350834794590725034250601696863236177277347396984`.

We can verify that our new signature works:

```py
s_inv = pow(s_f,-1,q)
assert Gen[0] == (Integer(s_inv*h_f) * Gen + Integer(s_inv*Integer(r_f)) * Q)[0] #here P=Gen
```

Hurray! We get the flag: `FCSC{7404379cbe060b26292407b89ee4e0ff7ad3c6cf65d3a5898dc805a47efc35b5}`.




